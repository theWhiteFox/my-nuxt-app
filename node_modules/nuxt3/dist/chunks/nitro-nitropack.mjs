import { join, resolve } from 'pathe';
import { createNitro, createDevServer, build, prepare, copyPublicAssets, scanMiddleware, writeTypes } from 'nitropack';
import { resolvePath } from '@nuxt/kit';
import fsExtra from 'fs-extra';
import { I as ImportProtectionPlugin } from './index.mjs';
import 'hookable';
import 'fs';
import 'knitwork';
import 'escape-string-regexp';
import 'url';
import 'ufo';
import 'scule';
import 'unplugin';
import 'mlly';
import 'magic-string';
import 'defu';
import 'globby';
import '@vue/shared';
import 'unimport';
import 'module';
import 'unctx/transform';
import 'chokidar';
import 'perfect-debounce';
import 'untyped';

async function initNitro(nuxt) {
  const nitroOptions = nuxt.options.nitro || {};
  const nitro = await createNitro({
    ...nitroOptions,
    rootDir: nuxt.options.rootDir,
    srcDir: join(nuxt.options.srcDir, "server"),
    buildDir: nuxt.options.buildDir,
    generateDir: join(nuxt.options.buildDir, "dist"),
    publicDir: nuxt.options.dir.public,
    publicPath: nuxt.options.app.buildAssetsDir,
    renderer: "#nitro/vue/render",
    modulesDir: nuxt.options.modulesDir,
    runtimeConfig: {
      public: nuxt.options.publicRuntimeConfig,
      private: nuxt.options.privateRuntimeConfig
    },
    output: {
      dir: nitroOptions.output?.dir || (nuxt.options.dev ? join(nuxt.options.buildDir, "nitro") : resolve(nuxt.options.rootDir, ".output"))
    },
    dev: nuxt.options.dev,
    preset: nuxt.options.dev ? "dev" : void 0
  });
  const nitroDevServer = nuxt.server = createDevServer(nitro);
  nitro.vfs = nuxt.vfs = nitro.vfs || nuxt.vfs || {};
  const nitroHooks = [
    "nitro:document"
  ];
  nuxt.hook("close", () => nitro.hooks.callHook("close"));
  for (const hook of nitroHooks) {
    nitro.hooks.hook(hook, (...args) => nuxt.callHook(hook, ...args));
  }
  nuxt.hook("close", () => nitro.hooks.callHook("close"));
  nitro.hooks.hook("nitro:document", (template) => nuxt.callHook("nitro:document", template));
  nitro.hooks.hook("nitro:rollup:before", (nitro2) => {
    nitro2.options.rollupConfig.plugins.push(ImportProtectionPlugin.rollup({
      rootDir: nuxt.options.rootDir,
      patterns: [
        ...["#app", /^#build(\/|$)/].map((p) => [p, "Vue app aliases are not allowed in server routes."])
      ]
    }));
  });
  nuxt.hook("prepare:types", (opts) => {
    opts.references.push({ path: resolve(nuxt.options.buildDir, "types/nitro.d.ts") });
  });
  nuxt.hook("modules:done", async () => {
    await nuxt.callHook("nitro:context", nitro);
    const { middleware, legacyMiddleware } = await resolveMiddleware(nuxt);
    nuxt.server.setLegacyMiddleware(legacyMiddleware);
    nitro.options.middleware.push(...middleware);
  });
  nuxt.hook("build:done", async () => {
    if (nuxt.options.dev) {
      await build(nitro);
    } else {
      await prepare(nitro);
      await copyPublicAssets(nitro);
      await build(nitro);
    }
  });
  nuxt.hook("build:before", async () => {
    nitro.scannedMiddleware = await scanMiddleware(nitro.options.srcDir);
    await writeTypes(nitro);
  });
  if (nuxt.options.dev) {
    nitro.hooks.hook("nitro:compiled", () => {
      nitroDevServer.watch();
    });
    nuxt.hook("build:compile", ({ compiler }) => {
      compiler.outputFileSystem = { ...fsExtra, join };
    });
    nuxt.hook("server:devMiddleware", (m) => {
      nitroDevServer.setDevMiddleware(m);
    });
  }
}
async function resolveMiddleware(nuxt) {
  const middleware = [];
  const legacyMiddleware = [];
  for (let m of nuxt.options.serverMiddleware) {
    if (typeof m === "string" || typeof m === "function") {
      m = { handler: m };
    }
    const route = m.path || m.route || "/";
    const handle = m.handler || m.handle;
    if (typeof handle !== "string" || typeof route !== "string") {
      legacyMiddleware.push(m);
    } else {
      delete m.handler;
      delete m.path;
      middleware.push({
        ...m,
        handle: await resolvePath(handle),
        route
      });
    }
  }
  return {
    middleware,
    legacyMiddleware
  };
}

export { initNitro };
