import { Worker } from 'worker_threads';
import { promises, existsSync, readFileSync, statSync, createWriteStream } from 'fs';
import chokidar, { watch } from 'chokidar';
import { debounce } from 'perfect-debounce';
import { defineEventHandler, createError, createApp } from 'h3';
import httpProxy from 'http-proxy';
import { listen } from 'listhen';
import serveStatic from 'serve-static';
import { resolve, dirname, relative, normalize, isAbsolute, join, extname } from 'pathe';
import connect from 'connect';
import { withBase, joinURL, withLeadingSlash, withoutTrailingSlash } from 'ufo';
import { createHooks } from 'hookable';
import { createUnimport } from 'unimport';
import consola from 'consola';
import { loadConfig } from 'c12';
import { klona } from 'klona/full';
import defu from 'defu';
import { createRequire } from 'module';
import fse from 'fs-extra';
import 'jiti';
import chalk from 'chalk';
import { getProperty } from 'dot-prop';
import { fileURLToPath, pathToFileURL } from 'url';
import archiver from 'archiver';
import { globby, globbySync } from 'globby';
import { readPackageJSON } from 'pkg-types';
import * as rollup from 'rollup';
import prettyBytes from 'pretty-bytes';
import { gzipSize } from 'gzip-size';
import { isTest, isDebug } from 'std-env';
import devalue from '@nuxt/devalue';
import { terser } from 'rollup-plugin-terser';
import commonjs from '@rollup/plugin-commonjs';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import alias from '@rollup/plugin-alias';
import json from '@rollup/plugin-json';
import replace from '@rollup/plugin-replace';
import virtual$1 from '@rollup/plugin-virtual';
import wasmPlugin from '@rollup/plugin-wasm';
import inject from '@rollup/plugin-inject';
import { visualizer } from 'rollup-plugin-visualizer';
import * as unenv from 'unenv';
import { isValidNodeImport, normalizeid, resolvePath as resolvePath$1, sanitizeFilePath } from 'mlly';
import unimportPlugin from 'unimport/unplugin';
import { nodeFileTrace } from '@vercel/nft';
import semver from 'semver';
import createEtag from 'etag';
import mime from 'mime';
import hasha from 'hasha';
import table from 'table';
import isPrimitive from 'is-primitive';
import { transform } from 'esbuild';
import { createFilter } from '@rollup/pluginutils';

async function printFSTree(dir) {
  if (isTest) {
    return;
  }
  const files = await globby("**/*.*", { cwd: dir });
  const items = (await Promise.all(files.map(async (file) => {
    const path = resolve(dir, file);
    const src = await promises.readFile(path);
    const size = src.byteLength;
    const gzip = await gzipSize(src);
    return { file, path, size, gzip };
  }))).sort((a, b) => b.path.localeCompare(a.path));
  let totalSize = 0;
  let totalGzip = 0;
  let totalNodeModulesSize = 0;
  let totalNodeModulesGzip = 0;
  items.forEach((item, index) => {
    dirname(item.file);
    const rpath = relative(process.cwd(), item.path);
    const treeChar = index === items.length - 1 ? "\u2514\u2500" : "\u251C\u2500";
    const isNodeModules = item.file.includes("node_modules");
    if (isNodeModules) {
      totalNodeModulesSize += item.size;
      totalNodeModulesGzip += item.gzip;
      return;
    }
    process.stdout.write(chalk.gray(`  ${treeChar} ${rpath} (${prettyBytes(item.size)}) (${prettyBytes(item.gzip)} gzip)
`));
    totalSize += item.size;
    totalGzip += item.gzip;
  });
  process.stdout.write(`${chalk.cyan("\u03A3 Total size:")} ${prettyBytes(totalSize + totalNodeModulesSize)} (${prettyBytes(totalGzip + totalNodeModulesGzip)} gzip)
`);
}

function hl(str) {
  return chalk.cyan(str);
}
function prettyPath(p, highlight = true) {
  p = relative(process.cwd(), p);
  return highlight ? hl(p) : p;
}
function compileTemplate(contents) {
  return (params) => contents.replace(/{{ ?([\w.]+) ?}}/g, (_, match) => {
    const val = getProperty(params, match);
    if (!val) {
      consola.warn(`cannot resolve template param '${match}' in ${contents.slice(0, 20)}`);
    }
    return val || `${match}`;
  });
}
function serializeTemplate(contents) {
  return `(params) => \`${contents.replace(/{{ (\w+) }}/g, "${params.$1}")}\``;
}
async function writeFile(file, contents, log = false) {
  await fse.mkdirp(dirname(file));
  await fse.writeFile(file, contents, "utf-8");
  if (log) {
    consola.info("Generated", prettyPath(file));
  }
}
function resolvePath(path, nitroOptions, base) {
  if (typeof path !== "string") {
    throw new TypeError("Invalid path: " + path);
  }
  path = compileTemplate(path)(nitroOptions);
  for (const base2 in nitroOptions.alias) {
    if (path.startsWith(base2)) {
      path = nitroOptions.alias[base2] + path.substring(base2.length);
    }
  }
  return resolve(base || nitroOptions.srcDir, path);
}
function detectTarget() {
  if (process.env.NETLIFY || process.env.NETLIFY_LOCAL) {
    return "netlify";
  }
  if (process.env.NOW_BUILDER) {
    return "vercel";
  }
  if (process.env.INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN) {
    return "azure";
  }
}
async function isDirectory(path) {
  try {
    return (await fse.stat(path)).isDirectory();
  } catch (_err) {
    return false;
  }
}
createRequire(import.meta.url);
function serializeImportName(id) {
  return "_" + id.replace(/[^a-zA-Z0-9_$]/g, "_");
}
function resolveAliases(aliases) {
  for (const key in aliases) {
    for (const alias in aliases) {
      if (!["~", "@", "#"].includes(alias[0])) {
        continue;
      }
      if (alias === "@" && !aliases[key].startsWith("@/")) {
        continue;
      }
      if (aliases[key].startsWith(alias)) {
        aliases[key] = aliases[alias] + aliases[key].slice(alias.length);
      }
    }
  }
  return aliases;
}

let distDir = dirname(fileURLToPath(import.meta.url));
if (distDir.endsWith("chunks")) {
  distDir = dirname(distDir);
}
const pkgDir = resolve(distDir, distDir.endsWith("/chunks") ? "../.." : "..");
const runtimeDir = resolve(distDir, "runtime");

const PLUGIN_NAME = "dynamic-require";
const HELPER_DYNAMIC = `\0${PLUGIN_NAME}.mjs`;
const DYNAMIC_REQUIRE_RE = /import\("\.\/" ?\+(.*)\).then/g;
function dynamicRequire({ dir, ignore, inline }) {
  return {
    name: PLUGIN_NAME,
    transform(code, _id) {
      return {
        code: code.replace(DYNAMIC_REQUIRE_RE, `import('${HELPER_DYNAMIC}').then(r => r.default || r).then(dynamicRequire => dynamicRequire($1)).then`),
        map: null
      };
    },
    resolveId(id) {
      return id === HELPER_DYNAMIC ? id : null;
    },
    async load(_id) {
      if (_id !== HELPER_DYNAMIC) {
        return null;
      }
      let files = [];
      try {
        const wpManifest = resolve(dir, "./server.manifest.json");
        files = await import(pathToFileURL(wpManifest).href).then((r) => Object.keys(r.files).filter((file) => !ignore.includes(file)));
      } catch {
        files = await globby("**/*.{cjs,mjs,js}", { cwd: dir, absolute: false, ignore });
      }
      const chunks = (await Promise.all(files.map(async (id) => ({
        id,
        src: resolve(dir, id).replace(/\\/g, "/"),
        name: serializeImportName(id),
        meta: await getWebpackChunkMeta(resolve(dir, id))
      })))).filter((chunk) => chunk.meta);
      return inline ? TMPL_INLINE({ chunks }) : TMPL_LAZY({ chunks });
    }
  };
}
async function getWebpackChunkMeta(src) {
  const chunk = await import(pathToFileURL(src).href).then((r) => r.default || r || {});
  const { id, ids, modules } = chunk;
  if (!id && !ids) {
    return null;
  }
  return {
    id,
    ids,
    moduleIds: Object.keys(modules || {})
  };
}
function TMPL_INLINE({ chunks }) {
  return `${chunks.map((i) => `import * as ${i.name} from '${i.src}'`).join("\n")}
const dynamicChunks = {
  ${chunks.map((i) => ` ['${i.id}']: ${i.name}`).join(",\n")}
};

export default function dynamicRequire(id) {
  return Promise.resolve(dynamicChunks[id]);
};`;
}
function TMPL_LAZY({ chunks }) {
  return `
const dynamicChunks = {
${chunks.map((i) => ` ['${i.id}']: () => import('${i.src}')`).join(",\n")}
};

export default function dynamicRequire(id) {
  return dynamicChunks[id]();
};`;
}

function externals(opts) {
  const trackedExternals = /* @__PURE__ */ new Set();
  const _resolveCache = /* @__PURE__ */ new Map();
  const _resolve = async (id) => {
    let resolved = _resolveCache.get(id);
    if (resolved) {
      return resolved;
    }
    resolved = await resolvePath$1(id, {
      conditions: opts.exportConditions,
      url: opts.moduleDirectories
    });
    _resolveCache.set(id, resolved);
    return resolved;
  };
  return {
    name: "node-externals",
    async resolveId(originalId, importer, options) {
      if (!originalId || originalId.startsWith("\0") || originalId.includes("?") || originalId.startsWith("#")) {
        return null;
      }
      if (originalId.startsWith(".")) {
        return null;
      }
      const id = normalize(originalId);
      const idWithoutNodeModules = id.split("node_modules/").pop();
      if (opts.inline.find((i) => id.startsWith(i) || idWithoutNodeModules.startsWith(i))) {
        return null;
      }
      const resolved = await this.resolve(originalId, importer, { ...options, skipSelf: true }) || { id };
      if (!existsSync(resolved.id)) {
        resolved.id = await _resolve(resolved.id);
      }
      if (!await isValidNodeImport(resolved.id)) {
        return {
          ...resolved,
          external: false
        };
      }
      if (opts.trace === false) {
        return {
          ...resolved,
          id: normalizeid(resolved.id),
          external: true
        };
      }
      const { pkgName, subpath } = parseNodeModulePath(resolved.id);
      if (!pkgName) {
        return null;
      }
      if (pkgName !== originalId) {
        if (!isAbsolute(originalId)) {
          const fullPath = await _resolve(originalId);
          trackedExternals.add(fullPath);
          return {
            id: originalId,
            external: true
          };
        }
        const packageEntry = await _resolve(pkgName).catch(() => null);
        if (packageEntry !== originalId) {
          const guessedSubpath = pkgName + subpath.replace(/\.[a-z]+$/, "");
          const resolvedGuess = await _resolve(guessedSubpath).catch(() => null);
          if (resolvedGuess === originalId) {
            trackedExternals.add(resolvedGuess);
            return {
              id: guessedSubpath,
              external: true
            };
          }
          return null;
        }
      }
      trackedExternals.add(resolved.id);
      return {
        id: pkgName,
        external: true
      };
    },
    async buildEnd() {
      if (opts.trace === false) {
        return;
      }
      for (const pkgName of opts.traceInclude || []) {
        const path = await this.resolve(pkgName);
        if (path?.id) {
          trackedExternals.add(path.id);
        }
      }
      const tracedFiles = await nodeFileTrace(Array.from(trackedExternals), opts.traceOptions).then((r) => Array.from(r.fileList).map((f) => resolve(opts.traceOptions.base, f))).then((r) => r.filter((file) => file.includes("node_modules")));
      const packageJSONCache = /* @__PURE__ */ new Map();
      const getPackageJson = async (pkgDir) => {
        if (packageJSONCache.has(pkgDir)) {
          return packageJSONCache.get(pkgDir);
        }
        const pkgJSON = JSON.parse(await promises.readFile(resolve(pkgDir, "package.json"), "utf8"));
        packageJSONCache.set(pkgDir, pkgJSON);
        return pkgJSON;
      };
      const tracedPackages = /* @__PURE__ */ new Map();
      for (const file of tracedFiles) {
        const { baseDir, pkgName } = parseNodeModulePath(file);
        if (!pkgName) {
          continue;
        }
        const pkgDir = resolve(baseDir, pkgName);
        const existingPkgDir = tracedPackages.get(pkgName);
        if (existingPkgDir && existingPkgDir !== pkgDir) {
          const v1 = await getPackageJson(existingPkgDir).then((r) => r.version);
          const v2 = await getPackageJson(pkgDir).then((r) => r.version);
          if (semver.gte(v1, v2)) {
            continue;
          }
          if (semver.major(v1) !== semver.major(v2)) {
            console.warn(`Multiple major versions of package ${pkgName} are being externalized. Picking latest version.
` + [
              existingPkgDir + "@" + v1,
              pkgDir + "@" + v2
            ].map((p) => "  - " + p).join("\n"));
          }
        }
        tracedPackages.set(pkgName, pkgDir);
      }
      for (const pkgDir of tracedPackages.values()) {
        const pkgJSON = join(pkgDir, "package.json");
        if (!tracedFiles.includes(pkgJSON)) {
          tracedFiles.push(pkgJSON);
        }
      }
      const writeFile = async (file) => {
        if (!await isFile(file)) {
          return;
        }
        const src = resolve(opts.traceOptions.base, file);
        const dst = resolve(opts.outDir, "node_modules", file.replace(/^.*?node_modules[\\/](.*)$/, "$1"));
        await promises.mkdir(dirname(dst), { recursive: true });
        await promises.copyFile(src, dst);
      };
      if (process.platform === "win32") {
        for (const file of tracedFiles) {
          await writeFile(file);
        }
      } else {
        await Promise.all(tracedFiles.map(writeFile));
      }
      await promises.writeFile(resolve(opts.outDir, "package.json"), JSON.stringify({
        private: true,
        bundledDependencies: Array.from(tracedPackages.keys())
      }, null, 2), "utf8");
    }
  };
}
function parseNodeModulePath(path) {
  if (!path) {
    return {};
  }
  const match = /^(.+\/node_modules\/)([^@/]+|@[^/]+\/[^/]+)(\/?.*?)?$/.exec(normalize(path));
  if (!match) {
    return {};
  }
  const [, baseDir, pkgName, subpath] = match;
  return {
    baseDir,
    pkgName,
    subpath
  };
}
async function isFile(file) {
  try {
    const stat = await promises.stat(file);
    return stat.isFile();
  } catch (err) {
    if (err.code === "ENOENT") {
      return false;
    }
    throw err;
  }
}

const TIMING = "globalThis.__timing__";
const iife = (code) => `(function() { ${code.trim()} })();`.replace(/\n/g, "");
const HELPER = iife(`
const start = () => Date.now();
const end = s => Date.now() - s;
const _s = {};
const metrics = [];
const logStart = id => { _s[id] = Date.now(); };
const logEnd = id => { const t = end(_s[id]); delete _s[id]; metrics.push([id, t]); console.debug('>', id + ' (' + t + 'ms)'); };
${TIMING} = { start, end, metrics, logStart, logEnd };
`);
function timing(_opts = {}) {
  return {
    name: "timing",
    renderChunk(code, chunk) {
      let name = chunk.fileName || "";
      name = name.replace(extname(name), "");
      const logName = name === "index" ? "Nitro Start" : "Load " + name;
      return {
        code: (chunk.isEntry ? HELPER : "") + `${TIMING}.logStart('${logName}');` + code + `;${TIMING}.logEnd('${logName}');`,
        map: null
      };
    }
  };
}

function publicAssets(nitro) {
  const assets = {};
  const files = globbySync("**/*.*", { cwd: nitro.options.output.publicDir, absolute: false });
  const publicAssetBases = nitro.options.publicAssets.filter((dir) => !dir.fallthrough && dir.baseURL !== "/").map((dir) => dir.baseURL);
  for (const id of files) {
    let type = mime.getType(id) || "text/plain";
    if (type.startsWith("text")) {
      type += "; charset=utf-8";
    }
    const fullPath = resolve(nitro.options.output.publicDir, id);
    const etag = createEtag(readFileSync(fullPath));
    const stat = statSync(fullPath);
    assets["/" + decodeURIComponent(id)] = {
      type,
      etag,
      mtime: stat.mtime.toJSON(),
      path: relative(nitro.options.output.serverDir, fullPath)
    };
  }
  return virtual$1({
    "#public-assets-data": `export default ${JSON.stringify(assets, null, 2)};`,
    "#public-assets": `
import { promises } from 'fs'
import { resolve } from 'pathe'
import { dirname } from 'pathe'
import { fileURLToPath } from 'url'
import assets from '#public-assets-data'

const mainDir = dirname(fileURLToPath(globalThis.entryURL))

export const publicAssetBases = ${JSON.stringify(publicAssetBases)}
export function isPublicAssetURL(id = '') {
  for (const base of publicAssetBases) {
    if (id.startsWith(base)) { return true }
  }
  return false
}

export function readAsset (id) {
  return promises.readFile(resolve(mainDir, getAsset(id).path)).catch(() => {})
}

export function getAsset (id) {
  return assets[id]
}
`
  });
}

const PREFIX = "\0virtual:";
function virtual(modules) {
  const _modules = /* @__PURE__ */ new Map();
  for (const [id, mod] of Object.entries(modules)) {
    _modules.set(id, mod);
    _modules.set(resolve(id), mod);
  }
  return {
    name: "virtual",
    resolveId(id, importer) {
      if (id in modules) {
        return PREFIX + id;
      }
      if (importer) {
        const importerNoPrefix = importer.startsWith(PREFIX) ? importer.slice(PREFIX.length) : importer;
        const resolved = resolve(dirname(importerNoPrefix), id);
        if (_modules.has(resolved)) {
          return PREFIX + resolved;
        }
      }
      return null;
    },
    async load(id) {
      if (!id.startsWith(PREFIX)) {
        return null;
      }
      const idNoPrefix = id.slice(PREFIX.length);
      if (!_modules.has(idNoPrefix)) {
        return null;
      }
      let m = _modules.get(idNoPrefix);
      if (typeof m !== "string" && typeof m.load === "function") {
        m = await m.load();
      }
      return {
        code: m,
        map: null
      };
    }
  };
}

function serverAssets(nitro) {
  if (nitro.options.dev) {
    return virtual({ "#server-assets": getAssetsDev(nitro) });
  }
  return virtual({
    "#server-assets": {
      async load() {
        const assets = {};
        for (const asset of nitro.options.serverAssets) {
          const files = await globby("**/*.*", { cwd: asset.dir, absolute: false });
          for (const _id of files) {
            const fsPath = resolve(asset.dir, _id);
            const id = asset.baseName + "/" + _id;
            assets[id] = { fsPath, meta: {} };
            let type = mime.getType(id) || "text/plain";
            if (type.startsWith("text")) {
              type += "; charset=utf-8";
            }
            const etag = createEtag(await promises.readFile(fsPath));
            const mtime = await promises.stat(fsPath).then((s) => s.mtime.toJSON());
            assets[id].meta = { type, etag, mtime };
          }
        }
        return getAssetProd(assets);
      }
    }
  });
}
function getAssetsDev(nitro) {
  return `
import { createStorage } from 'unstorage'
import fsDriver from 'unstorage/drivers/fs'

const serverAssets = ${JSON.stringify(nitro.options.serverAssets)}

export const assets = createStorage()

for (const asset of serverAssets) {
  assets.mount(asset.base, fsDriver({ base: asset.dir }))
}`;
}
function normalizeKey(key) {
  return key.replace(/[/\\]/g, ":").replace(/^:|:$/g, "");
}
function getAssetProd(assets) {
  return `
const _assets = {
${Object.entries(assets).map(([id, asset]) => `  ['${normalizeKey(id)}']: {
    import: () => import('${asset.fsPath}').then(r => r.default || r),
    meta: ${JSON.stringify(asset.meta)}
  }`).join(",\n")}
}

${normalizeKey.toString()}

export const assets = {
  getKeys() {
    return Object.keys(_assets)
  },
  hasItem (id) {
    id = normalizeKey(id)
    return id in _assets
  },
  getItem (id) {
    id = normalizeKey(id)
    return _assets[id] ? _assets[id].import() : null
  },
  getMeta (id) {
    id = normalizeKey(id)
    return _assets[id] ? _assets[id].meta : {}
  }
}
`;
}

const unique = (arr) => Array.from(new Set(arr));
function handlers(getHandlers) {
  const getImportId = (p) => "_" + hasha(p).slice(0, 6);
  let lastDump = "";
  return virtual({
    "#server-handlers": {
      load: () => {
        const handler = getHandlers();
        if (isDebug) {
          const dumped = dumpHandler(handler);
          if (dumped !== lastDump) {
            lastDump = dumped;
            if (handler.length) {
              console.log(dumped);
            }
          }
        }
        const imports = unique(handler.filter((m) => m.lazy === false).map((m) => m.handler));
        const lazyImports = unique(handler.filter((m) => m.lazy !== false && !imports.includes(m.handler)).map((m) => m.handler));
        const code = `
${imports.map((handler2) => `import ${getImportId(handler2)} from '${handler2}';`).join("\n")}

${lazyImports.map((handler2) => `const ${getImportId(handler2)} = () => import('${handler2}');`).join("\n")}

const handlers = [
${handler.map((m) => `  { route: '${m.route || "/"}', handler: ${getImportId(m.handler)}, lazy: ${m.lazy || true} }`).join(",\n")}
];

export default handlers
  `.trim();
        return code;
      }
    }
  });
}
function dumpHandler(handler) {
  const data = handler.map(({ route, handler: handler2, ...props }) => {
    return [
      route && route !== "/" ? route : "*",
      relative(process.cwd(), handler2),
      dumpObject(props)
    ];
  });
  return table.table([
    ["Path", "Handler", "Options"],
    ...data
  ], {
    singleLine: true,
    border: table.getBorderCharacters("norc")
  });
}
function dumpObject(obj) {
  const items = [];
  for (const key in obj) {
    const val = obj[key];
    items.push(`${key}: ${isPrimitive(val) ? val : JSON.stringify(val)}`);
  }
  return items.join(", ");
}

const defaultLoaders = {
  ".ts": "ts",
  ".js": "js"
};
function esbuild(options = {}) {
  let target;
  const loaders = {
    ...defaultLoaders
  };
  if (options.loaders) {
    for (const key of Object.keys(options.loaders)) {
      const value = options.loaders[key];
      if (typeof value === "string") {
        loaders[key] = value;
      } else if (value === false) {
        delete loaders[key];
      }
    }
  }
  const extensions = Object.keys(loaders);
  const INCLUDE_REGEXP = new RegExp(`\\.(${extensions.map((ext) => ext.slice(1)).join("|")})$`);
  const EXCLUDE_REGEXP = /node_modules/;
  const filter = createFilter(options.include || INCLUDE_REGEXP, options.exclude || EXCLUDE_REGEXP);
  return {
    name: "esbuild",
    async transform(code, id) {
      if (!filter(id)) {
        return null;
      }
      const ext = extname(id);
      const loader = loaders[ext];
      if (!loader) {
        return null;
      }
      target = options.target || "node12";
      const result = await transform(code, {
        loader,
        target,
        define: options.define,
        sourcemap: options.sourceMap !== false,
        sourcefile: id
      });
      printWarnings(id, result, this);
      return result.code && {
        code: result.code,
        map: result.map || null
      };
    },
    async renderChunk(code) {
      if (options.minify) {
        const result = await transform(code, {
          loader: "js",
          minify: true,
          target
        });
        if (result.code) {
          return {
            code: result.code,
            map: result.map || null
          };
        }
      }
      return null;
    }
  };
}
function printWarnings(id, result, plugin) {
  if (result.warnings) {
    for (const warning of result.warnings) {
      let message = "[esbuild]";
      if (warning.location) {
        message += ` (${relative(process.cwd(), id)}:${warning.location.line}:${warning.location.column})`;
      }
      message += ` ${warning.text}`;
      plugin.warn(message);
    }
  }
}

function raw(opts = {}) {
  const extensions = new Set([".md", ".mdx", ".yml", ".txt", ".css", ".htm", ".html"].concat(opts.extensions || []));
  return {
    name: "raw",
    transform(code, id) {
      if (id[0] !== "\0" && extensions.has(extname(id))) {
        return {
          code: `// ${id}
export default ${JSON.stringify(code)}`,
          map: null
        };
      }
    }
  };
}

const drivers = {
  fs: "unstorage/drivers/fs",
  http: "unstorage/drivers/http",
  memory: "unstorage/drivers/memory"
};
function storage(opts) {
  const mounts = [];
  for (const path in opts.mounts) {
    const mount = opts.mounts[path];
    mounts.push({
      path,
      driver: drivers[mount.driver] || mount.driver,
      opts: mount.driverOptions || {}
    });
  }
  const driverImports = Array.from(new Set(mounts.map((m) => m.driver)));
  return virtual$1({
    "#storage": `
import { createStorage } from 'unstorage'
import { assets } from '#server-assets'

${driverImports.map((i) => `import ${serializeImportName(i)} from '${i}'`).join("\n")}

export const storage = createStorage({})

storage.mount('/assets', assets)

${mounts.map((m) => `storage.mount('${m.path}', ${serializeImportName(m.driver)}(${JSON.stringify(m.opts)}))`).join("\n")}
`
  });
}

const getRollupConfig = (nitro) => {
  const extensions = [".ts", ".mjs", ".js", ".json", ".node"];
  const nodePreset = nitro.options.node === false ? unenv.nodeless : unenv.node;
  const builtinPreset = {
    alias: {
      debug: "unenv/runtime/npm/debug",
      consola: "unenv/runtime/npm/consola",
      ...nitro.options.alias
    }
  };
  const env = unenv.env(nodePreset, builtinPreset, nitro.options.unenv);
  if (nitro.options.sourceMap) {
    env.polyfill.push("source-map-support/register.js");
  }
  const buildServerDir = join(nitro.options.buildDir, "dist/server");
  const runtimeAppDir = join(runtimeDir, "app");
  const rollupConfig = {
    input: nitro.options.entry,
    output: {
      dir: nitro.options.output.serverDir,
      entryFileNames: "index.mjs",
      chunkFileNames(chunkInfo) {
        let prefix = "";
        const modules = Object.keys(chunkInfo.modules);
        const lastModule = modules[modules.length - 1];
        if (lastModule.startsWith(buildServerDir)) {
          prefix = join("app", relative(buildServerDir, dirname(lastModule)));
        } else if (lastModule.startsWith(runtimeAppDir)) {
          prefix = "app";
        } else if (lastModule.startsWith(nitro.options.buildDir)) {
          prefix = "nuxt";
        } else if (lastModule.startsWith(runtimeDir)) {
          prefix = "nitro";
        } else if (nitro.options.handlers.find((m) => lastModule.startsWith(m.handler))) {
          prefix = "handlers";
        } else if (lastModule.includes("assets")) {
          prefix = "assets";
        }
        return join("chunks", prefix, "[name].mjs");
      },
      inlineDynamicImports: nitro.options.inlineDynamicImports,
      format: "esm",
      exports: "auto",
      intro: "",
      outro: "",
      preferConst: true,
      sanitizeFileName: sanitizeFilePath,
      sourcemap: nitro.options.sourceMap,
      sourcemapExcludeSources: true,
      sourcemapPathTransform(relativePath, sourcemapPath) {
        return resolve(dirname(sourcemapPath), relativePath);
      }
    },
    external: env.external,
    makeAbsoluteExternalsRelative: false,
    plugins: [],
    onwarn(warning, rollupWarn) {
      if (!["CIRCULAR_DEPENDENCY", "EVAL"].includes(warning.code) && !warning.message.includes("Unsupported source map comment")) {
        rollupWarn(warning);
      }
    },
    treeshake: {
      moduleSideEffects(id) {
        return nitro.options.moduleSideEffects.some((match) => id.startsWith(match));
      }
    }
  };
  if (nitro.options.timing) {
    rollupConfig.plugins.push(timing());
  }
  if (nitro.options.autoImport) {
    rollupConfig.plugins.push(unimportPlugin.rollup(nitro.options.autoImport));
  }
  rollupConfig.plugins.push(raw());
  if (nitro.options.experimental.wasm) {
    rollupConfig.plugins.push(wasmPlugin());
  }
  rollupConfig.plugins.push(replace({
    preventAssignment: true,
    values: {
      "process.env.NODE_ENV": nitro.options.dev ? '"development"' : '"production"',
      "typeof window": '"undefined"',
      "global.": "globalThis.",
      "process.server": "true",
      "process.client": "false",
      "process.dev": String(nitro.options.dev),
      "process.env.RUNTIME_CONFIG": devalue(nitro.options.runtimeConfig),
      "process.env.DEBUG": JSON.stringify(nitro.options.dev),
      ...nitro.options.replace
    }
  }));
  rollupConfig.plugins.push(esbuild({
    target: "es2019",
    sourceMap: true,
    ...nitro.options.esbuild?.options
  }));
  rollupConfig.plugins.push(dynamicRequire({
    dir: resolve(nitro.options.buildDir, "dist/server"),
    inline: nitro.options.node === false || nitro.options.inlineDynamicImports,
    ignore: [
      "client.manifest.mjs",
      "server.js",
      "server.cjs",
      "server.mjs",
      "server.manifest.mjs"
    ]
  }));
  rollupConfig.plugins.push(serverAssets(nitro));
  if (nitro.options.serveStatic) {
    rollupConfig.plugins.push({
      name: "dirnames",
      renderChunk(code, chunk) {
        return {
          code: (chunk.isEntry ? "globalThis.entryURL = import.meta.url;" : "") + code,
          map: null
        };
      }
    });
    rollupConfig.plugins.push(publicAssets(nitro));
  }
  rollupConfig.plugins.push(storage(nitro.options.storage));
  rollupConfig.plugins.push(handlers(() => {
    const handlers2 = [
      ...nitro.scannedHandlers,
      ...nitro.options.handlers
    ];
    if (nitro.options.serveStatic) {
      handlers2.unshift({ handler: "#nitro/static" });
    }
    if (nitro.options.renderer) {
      handlers2.push({ handler: nitro.options.renderer });
    }
    return handlers2;
  }));
  rollupConfig.plugins.push(virtual$1({
    "#polyfill": env.polyfill.map((p) => `import '${p}';`).join("\n")
  }));
  rollupConfig.plugins.push(alias({
    entries: resolveAliases({
      "#nitro": runtimeDir,
      "#config": resolve(runtimeDir, "config"),
      "#nitro-error": resolve(runtimeDir, "error"),
      "#_config": resolve(runtimeDir, "config"),
      "#paths": resolve(runtimeDir, "paths"),
      "#cache": resolve(runtimeDir, "cache"),
      "#build": nitro.options.buildDir,
      "~": nitro.options.srcDir,
      "@/": nitro.options.srcDir,
      "~~": nitro.options.rootDir,
      "@@/": nitro.options.rootDir,
      ...env.alias
    })
  }));
  if (nitro.options.externals) {
    rollupConfig.plugins.push(externals(defu(nitro.options.externals, {
      outDir: nitro.options.output.serverDir,
      moduleDirectories: nitro.options.nodeModulesDirs,
      external: [
        ...nitro.options.dev ? [nitro.options.buildDir] : []
      ],
      inline: [
        "#",
        "~",
        "@/",
        "~~",
        "@@/",
        "virtual:",
        runtimeDir,
        nitro.options.srcDir,
        ...nitro.options.handlers.map((m) => m.handler).filter((i) => typeof i === "string"),
        ...nitro.options.dev ? [] : ["vue", "@vue/", "@nuxt/"]
      ],
      traceOptions: {
        base: "/",
        processCwd: nitro.options.rootDir,
        exportsOnly: true
      },
      exportConditions: [
        "default",
        "module",
        "node",
        "import"
      ]
    })));
  }
  rollupConfig.plugins.push(nodeResolve({
    extensions,
    preferBuiltins: true,
    rootDir: nitro.options.rootDir,
    moduleDirectories: nitro.options.nodeModulesDirs,
    mainFields: ["main"],
    exportConditions: [
      "default",
      "module",
      "node",
      "import"
    ]
  }));
  rollupConfig.plugins.push(commonjs({
    esmExternals: (id) => !id.startsWith("unenv/"),
    requireReturnsDefault: "auto"
  }));
  rollupConfig.plugins.push(json());
  rollupConfig.plugins.push(inject(env.inject));
  if (nitro.options.minify) {
    rollupConfig.plugins.push(terser({
      mangle: {
        keep_fnames: true,
        keep_classnames: true
      },
      format: {
        comments: false
      }
    }));
  }
  if (nitro.options.analyze) {
    rollupConfig.plugins.push(visualizer({
      ...nitro.options.analyze,
      filename: nitro.options.analyze.filename.replace("{name}", "nitro"),
      title: "Nitro Server bundle stats"
    }));
  }
  return rollupConfig;
};

const GLOB_SCAN_PATTERN = "**/*.{ts,mjs,js,cjs}";
async function scanHandlers(nitro) {
  const handlers = await Promise.all([
    scanMiddleware(nitro),
    scanAPI(nitro)
  ]).then((r) => r.flat());
  nitro.scannedHandlers = handlers.flatMap((h) => h.handlers);
  return handlers;
}
function scanMiddleware(nitro) {
  return scanServerDir(nitro, "middleware", (file) => ({ handler: file.path, route: "/" }));
}
function scanAPI(nitro) {
  return scanServerDir(nitro, "api", (file) => ({ handler: file.path, route: withBase(file.name.replace(/\[([a-z]+)\]/g, ":$1"), "/api") }));
}
async function scanServerDir(nitro, name, mapper) {
  const dirs = nitro.options.scanDirs.map((dir) => join(dir, name));
  const files = await scanDirs(dirs);
  const handlers = files.map(mapper);
  return { dirs, files, handlers };
}
function scanDirs(dirs) {
  return Promise.all(dirs.map(async (dir) => {
    const fileNames = await globby(GLOB_SCAN_PATTERN, { cwd: dir, dot: true });
    return fileNames.map((fileName) => {
      return {
        dir,
        name: fileName.replace(/\.[a-z]+$/, "").replace(/\/index$/, ""),
        path: resolve(dir, fileName)
      };
    }).sort((a, b) => b.path.localeCompare(a.path));
  })).then((r) => r.flat());
}

async function prepare(nitro) {
  await cleanupDir(nitro.options.output.dir);
  if (!nitro.options.output.publicDir.startsWith(nitro.options.output.dir)) {
    await cleanupDir(nitro.options.output.publicDir);
  }
  if (!nitro.options.output.serverDir.startsWith(nitro.options.output.dir)) {
    await cleanupDir(nitro.options.output.serverDir);
  }
}
async function cleanupDir(dir) {
  await fse.emptyDir(dir);
}
async function copyPublicAssets(nitro) {
  for (const asset of nitro.options.publicAssets) {
    if (await isDirectory(asset.dir)) {
      await fse.copy(asset.dir, join(nitro.options.output.publicDir, asset.baseURL));
    }
  }
  nitro.logger.success("Generated public " + prettyPath(nitro.options.output.publicDir));
}
async function build(nitro) {
  const htmlSrc = resolve(nitro.options.buildDir, "views/app.template.html");
  const htmlTemplate = { src: htmlSrc, contents: "", dst: "" };
  htmlTemplate.dst = htmlTemplate.src.replace(/.html$/, ".mjs").replace("app.template.mjs", "document.template.mjs");
  htmlTemplate.contents = nitro.vfs[htmlTemplate.src] || await fse.readFile(htmlTemplate.src, "utf-8").catch(() => "");
  if (htmlTemplate.contents) {
    await nitro.hooks.callHook("nitro:document", htmlTemplate);
    const compiled = "export default " + serializeTemplate(htmlTemplate.contents);
    await writeFile(htmlTemplate.dst, compiled);
  }
  nitro.options.rollupConfig = getRollupConfig(nitro);
  await nitro.hooks.callHook("nitro:rollup:before", nitro);
  return nitro.options.dev ? _watch(nitro) : _build(nitro);
}
async function writeTypes(nitro) {
  const routeTypes = {};
  const middleware = [
    ...nitro.scannedHandlers,
    ...nitro.options.handlers
  ];
  for (const mw of middleware) {
    if (typeof mw.handler !== "string") {
      continue;
    }
    const relativePath = relative(join(nitro.options.buildDir, "types"), mw.handler).replace(/\.[a-z]+$/, "");
    routeTypes[mw.route] = routeTypes[mw.route] || [];
    routeTypes[mw.route].push(`Awaited<ReturnType<typeof import('${relativePath}').default>>`);
  }
  let autoImportedTypes = [];
  if (nitro.unimport) {
    autoImportedTypes = [
      nitro.unimport.generateTypeDecarations({ exportHelper: false }).trim()
    ];
  }
  const lines = [
    "// Generated by nitro",
    "declare module 'nitropack' {",
    "  type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T",
    "  interface InternalApi {",
    ...Object.entries(routeTypes).map(([path, types]) => `    '${path}': ${types.join(" | ")}`),
    "  }",
    "}",
    ...autoImportedTypes,
    "export {}"
  ];
  await writeFile(join(nitro.options.buildDir, "types/nitro.d.ts"), lines.join("\n"));
}
async function _build(nitro) {
  await scanHandlers(nitro);
  await writeTypes(nitro);
  nitro.logger.start("Building server...");
  const build2 = await rollup.rollup(nitro.options.rollupConfig).catch((error) => {
    nitro.logger.error("Rollup error: " + error.message);
    throw error;
  });
  nitro.logger.start("Writing server bundle...");
  await build2.write(nitro.options.rollupConfig.output);
  const nitroConfigPath = resolve(nitro.options.output.dir, "nitro.json");
  const buildInfo = {
    date: new Date(),
    preset: nitro.options.preset,
    commands: {
      preview: nitro.options.commands.preview,
      deploy: nitro.options.commands.deploy
    }
  };
  await writeFile(nitroConfigPath, JSON.stringify(buildInfo, null, 2));
  nitro.logger.success("Server built");
  if (nitro.options.logLevel > 1) {
    await printFSTree(nitro.options.output.serverDir);
  }
  await nitro.hooks.callHook("nitro:compiled", nitro);
  const rOutput = relative(process.cwd(), nitro.options.output.dir);
  const rewriteRelativePaths = (input) => {
    return input.replaceAll(/\s\.\/([^\s]+)/g, ` ${rOutput}/$1`);
  };
  if (buildInfo.commands.preview) {
    nitro.logger.info(`You can preview this build using \`${rewriteRelativePaths(buildInfo.commands.preview)}\``);
  }
  if (buildInfo.commands.deploy) {
    nitro.logger.info(`You can deploy this build using \`${rewriteRelativePaths(buildInfo.commands.deploy)}\``);
  }
  return {
    entry: resolve(nitro.options.rollupConfig.output.dir, nitro.options.rollupConfig.output.entryFileNames)
  };
}
function startRollupWatcher(nitro) {
  const watcher = rollup.watch(nitro.options.rollupConfig);
  let start;
  watcher.on("event", (event) => {
    switch (event.code) {
      case "START":
        return;
      case "BUNDLE_START":
        start = Date.now();
        return;
      case "END":
        nitro.hooks.callHook("nitro:compiled", nitro);
        nitro.logger.success("Nitro built", start ? `in ${Date.now() - start} ms` : "");
        nitro.hooks.callHook("nitro:dev:reload");
        return;
      case "ERROR":
        nitro.logger.error("Rollup error: ", event.error);
    }
  });
  return watcher;
}
async function _watch(nitro) {
  let rollupWatcher;
  const reload = debounce(async () => {
    if (rollupWatcher) {
      await rollupWatcher.close();
    }
    await scanHandlers(nitro);
    rollupWatcher = startRollupWatcher(nitro);
    await writeTypes(nitro);
  });
  const watchPatterns = nitro.options.scanDirs.flatMap((dir) => [
    join(dir, "api"),
    join(dir, "middleware", GLOB_SCAN_PATTERN)
  ]);
  const watchReloadEvents = /* @__PURE__ */ new Set(["add", "addDir", "unlink", "unlinkDir"]);
  const reloadWacher = watch(watchPatterns, { ignoreInitial: true }).on("all", (event) => {
    if (watchReloadEvents.has(event)) {
      reload();
    }
  });
  nitro.hooks.hook("close", () => {
    rollupWatcher.close();
    reloadWacher.close();
  });
  await reload();
}

function defineNitroPreset(preset) {
  return preset;
}

const azure_functions = defineNitroPreset({
  serveStatic: true,
  entry: "#nitro/entries/azure_functions",
  externals: true,
  commands: {
    deploy: "az functionapp deployment source config-zip -g <resource-group> -n <app-name> --src {{ output.dir }}/deploy.zip"
  },
  hooks: {
    async "nitro:compiled"(ctx) {
      await writeRoutes$3(ctx);
    }
  }
});
function zipDirectory(dir, outfile) {
  const archive = archiver("zip", { zlib: { level: 9 } });
  const stream = createWriteStream(outfile);
  return new Promise((resolve2, reject) => {
    archive.directory(dir, false).on("error", (err) => reject(err)).pipe(stream);
    stream.on("close", () => resolve2(void 0));
    archive.finalize();
  });
}
async function writeRoutes$3(nitro) {
  const host = {
    version: "2.0",
    extensions: { http: { routePrefix: "" } }
  };
  const functionDefinition = {
    entryPoint: "handle",
    bindings: [
      {
        authLevel: "anonymous",
        type: "httpTrigger",
        direction: "in",
        name: "req",
        route: "{*url}",
        methods: [
          "delete",
          "get",
          "head",
          "options",
          "patch",
          "post",
          "put"
        ]
      },
      {
        type: "http",
        direction: "out",
        name: "res"
      }
    ]
  };
  await writeFile(resolve(nitro.options.srcDir, "function.json"), JSON.stringify(functionDefinition));
  await writeFile(resolve(nitro.options.output.dir, "host.json"), JSON.stringify(host));
  await zipDirectory(nitro.options.output.dir, join(nitro.options.output.dir, "deploy.zip"));
}

const azure = defineNitroPreset({
  entry: "#nitro/entries/azure",
  externals: true,
  output: {
    serverDir: "{{ output.dir }}/server/functions"
  },
  commands: {
    preview: "npx @azure/static-web-apps-cli start ./public --api-location ./server"
  },
  hooks: {
    async "nitro:compiled"(ctx) {
      await writeRoutes$2(ctx);
    }
  }
});
async function writeRoutes$2(nitro) {
  const host = {
    version: "2.0"
  };
  const config = {
    routes: [],
    navigationFallback: {
      rewrite: "/api/server"
    }
  };
  const indexPath = resolve(nitro.options.output.publicDir, "index.html");
  const indexFileExists = fse.existsSync(indexPath);
  if (!indexFileExists) {
    config.routes.unshift({
      route: "/index.html",
      redirect: "/"
    }, {
      route: "/",
      rewrite: "/api/server"
    });
  }
  const folderFiles = await globby([
    join(nitro.options.output.publicDir, "index.html"),
    join(nitro.options.output.publicDir, "**/index.html")
  ]);
  const prefix = nitro.options.output.publicDir.length;
  const suffix = "/index.html".length;
  folderFiles.forEach((file) => config.routes.unshift({
    route: file.slice(prefix, -suffix) || "/",
    rewrite: file.slice(prefix)
  }));
  const otherFiles = await globby([join(nitro.options.output.publicDir, "**/*.html"), join(nitro.options.output.publicDir, "*.html")]);
  otherFiles.forEach((file) => {
    if (file.endsWith("index.html")) {
      return;
    }
    const route = file.slice(prefix, ".html".length);
    const existingRouteIndex = config.routes.findIndex((_route) => _route.route === route);
    if (existingRouteIndex > -1) {
      config.routes.splice(existingRouteIndex, 1);
    }
    config.routes.unshift({
      route,
      rewrite: file.slice(prefix)
    });
  });
  const functionDefinition = {
    entryPoint: "handle",
    bindings: [
      {
        authLevel: "anonymous",
        type: "httpTrigger",
        direction: "in",
        name: "req",
        route: "{*url}",
        methods: ["delete", "get", "head", "options", "patch", "post", "put"]
      },
      {
        type: "http",
        direction: "out",
        name: "res"
      }
    ]
  };
  await writeFile(resolve(nitro.options.output.serverDir, "function.json"), JSON.stringify(functionDefinition));
  await writeFile(resolve(nitro.options.output.serverDir, "../host.json"), JSON.stringify(host));
  await writeFile(resolve(nitro.options.output.publicDir, "staticwebapp.config.json"), JSON.stringify(config));
  if (!indexFileExists) {
    await writeFile(indexPath, "");
  }
}

const browser = defineNitroPreset((_input) => {
  const baseURL = "/";
  const script = `<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function () {
    navigator.serviceWorker.register('${joinURL(baseURL, "sw.js")}');
  });
}
<\/script>`;
  const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="prefetch" href="${joinURL(baseURL, "sw.js")}">
  <link rel="prefetch" href="${joinURL(baseURL, "_server/index.mjs")}">
  <script>
  async function register () {
    const registration = await navigator.serviceWorker.register('${joinURL(baseURL, "sw.js")}')
    await navigator.serviceWorker.ready
    registration.active.addEventListener('statechange', (event) => {
      if (event.target.state === 'activated') {
        window.location.reload()
      }
    })
  }
  if (location.hostname !== 'localhost' && location.protocol === 'http:') {
    location.replace(location.href.replace('http://', 'https://'))
  } else {
    register()
  }
  <\/script>
</head>

<body>
  Loading...
</body>

</html>`;
  return {
    extends: "worker",
    entry: "#nitro/entries/service-worker",
    output: {
      serverDir: "{{ output.dir }}/public/_server"
    },
    hooks: {
      "nitro:document"(tmpl) {
        tmpl.contents = tmpl.contents.replace("</body>", script + "</body>");
      },
      async "nitro:compiled"(nitro) {
        await promises.writeFile(resolve(nitro.options.output.publicDir, "sw.js"), `self.importScripts('${joinURL(baseURL, "_server/index.mjs")}');`, "utf8");
        if (!existsSync(resolve(nitro.options.output.publicDir, "index.html"))) {
          await promises.writeFile(resolve(nitro.options.output.publicDir, "index.html"), html, "utf8");
        }
        if (!existsSync(resolve(nitro.options.output.publicDir, "200.html"))) {
          await promises.writeFile(resolve(nitro.options.output.publicDir, "200.html"), html, "utf8");
        }
        if (!existsSync(resolve(nitro.options.output.publicDir, "404.html"))) {
          await promises.writeFile(resolve(nitro.options.output.publicDir, "404.html"), html, "utf8");
        }
        nitro.logger.info("Ready to deploy to static hosting:", prettyPath(nitro.options.output.publicDir));
      }
    }
  };
});

const cloudflare = defineNitroPreset({
  extends: "worker",
  entry: "#nitro/entries/cloudflare",
  ignore: [
    "wrangler.toml"
  ],
  commands: {
    preview: "npx miniflare ./server/index.mjs --site ./public",
    deploy: "cd ./server && npx wrangler publish"
  },
  hooks: {
    async "nitro:compiled"(nitro) {
      await writeFile(resolve(nitro.options.output.dir, "package.json"), JSON.stringify({ private: true, main: "./server/index.mjs" }, null, 2));
      await writeFile(resolve(nitro.options.output.dir, "package-lock.json"), JSON.stringify({ lockfileVersion: 1 }, null, 2));
    }
  }
});

const firebase = defineNitroPreset({
  entry: "#nitro/entries/firebase",
  externals: true,
  commands: {
    deploy: "npx firebase deploy"
  },
  hooks: {
    async "nitro:compiled"(ctx) {
      await writeRoutes$1(ctx);
    }
  }
});
async function writeRoutes$1(nitro) {
  if (!fse.existsSync(join(nitro.options.rootDir, "firebase.json"))) {
    const firebase2 = {
      functions: {
        source: relative(nitro.options.rootDir, nitro.options.srcDir)
      },
      hosting: [
        {
          site: "<your_project_id>",
          public: relative(nitro.options.rootDir, nitro.options.output.publicDir),
          cleanUrls: true,
          rewrites: [
            {
              source: "**",
              function: "server"
            }
          ]
        }
      ]
    };
    await writeFile(resolve(nitro.options.rootDir, "firebase.json"), JSON.stringify(firebase2));
  }
  const _require = createRequire(import.meta.url);
  const jsons = await globby(`${nitro.options.srcDir}/node_modules/**/package.json`);
  const prefixLength = `${nitro.options.srcDir}/node_modules/`.length;
  const suffixLength = "/package.json".length;
  const dependencies = jsons.reduce((obj, packageJson) => {
    const dirname = packageJson.slice(prefixLength, -suffixLength);
    if (!dirname.includes("node_modules")) {
      obj[dirname] = _require(packageJson).version;
    }
    return obj;
  }, {});
  let nodeVersion = "14";
  try {
    const currentNodeVersion = fse.readJSONSync(join(nitro.options.rootDir, "package.json")).engines.node;
    if (["16", "14"].includes(currentNodeVersion)) {
      nodeVersion = currentNodeVersion;
    }
  } catch {
  }
  const getPackageVersion = async (id) => {
    const pkg = await readPackageJSON(id, { url: nitro.options.nodeModulesDirs });
    return pkg.version;
  };
  await writeFile(resolve(nitro.options.srcDir, "package.json"), JSON.stringify({
    private: true,
    type: "module",
    main: "./index.mjs",
    dependencies,
    devDependencies: {
      "firebase-functions-test": "latest",
      "firebase-admin": await getPackageVersion("firebase-admin"),
      "firebase-functions": await getPackageVersion("firebase-functions")
    },
    engines: { node: nodeVersion }
  }, null, 2));
}

const lambda = defineNitroPreset({
  entry: "#nitro/entries/lambda",
  externals: true
});

const netlify = defineNitroPreset({
  extends: "lambda",
  output: {
    dir: "{{ options.rootDir }}/.netlify/functions-internal",
    publicDir: "{{ options.rootDir }}/dist"
  },
  hooks: {
    async "nitro:compiled"(nitro) {
      const redirectsPath = join(nitro.options.output.publicDir, "_redirects");
      let contents = "/* /.netlify/functions/server 200";
      if (existsSync(redirectsPath)) {
        const currentRedirects = await promises.readFile(redirectsPath, "utf-8");
        if (currentRedirects.match(/^\/\* /m)) {
          nitro.logger.info("Not adding Nitro fallback to `_redirects` (as an existing fallback was found).");
          return;
        }
        nitro.logger.info("Adding Nitro fallback to `_redirects` to handle all unmatched routes.");
        contents = currentRedirects + "\n" + contents;
      }
      await promises.writeFile(redirectsPath, contents);
    },
    "nitro:rollup:before"(nitro) {
      nitro.options.rollupConfig.output.entryFileNames = "server.ts";
    }
  },
  ignore: [
    "netlify.toml",
    "_redirects"
  ]
});
const netlify_builder = defineNitroPreset({
  extends: netlify,
  entry: "#nitro/entries/netlify_builder"
});

const node = defineNitroPreset({
  entry: "#nitro/entries/node",
  externals: true
});

const dev = defineNitroPreset({
  extends: "node",
  entry: "#nitro/entries/dev",
  output: {
    serverDir: "{{ buildDir }}/dev"
  },
  externals: { trace: false },
  inlineDynamicImports: true,
  sourceMap: true
});

const prerender$1 = defineNitroPreset({
  extends: "node",
  entry: "#nitro/entries/node",
  output: {
    serverDir: "{{ buildDir }}/prerender"
  },
  externals: { trace: false }
});

const server = defineNitroPreset({
  extends: "node",
  entry: "#nitro/entries/server",
  serveStatic: true,
  commands: {
    preview: "node ./server/index.mjs"
  }
});

const cli = defineNitroPreset({
  extends: "node",
  entry: "#nitro/entries/cli",
  commands: {
    preview: "Run with node ./server/index.mjs [route]"
  }
});

const vercel = defineNitroPreset({
  extends: "node",
  entry: "#nitro/entries/vercel",
  output: {
    dir: "{{ rootDir }}/.vercel_build_output",
    serverDir: "{{ output.dir }}/functions/node/server",
    publicDir: "{{ output.dir }}/static"
  },
  ignore: [
    "vercel.json"
  ],
  hooks: {
    async "nitro:compiled"(nitro) {
      await writeRoutes(nitro);
    }
  }
});
async function writeRoutes(nitro) {
  const routes = [
    {
      src: "/sw.js",
      headers: {
        "cache-control": "public, max-age=0, must-revalidate"
      },
      continue: true
    },
    {
      src: "/_nuxt/(.*)",
      headers: {
        "cache-control": "public,max-age=31536000,immutable"
      },
      continue: true
    },
    {
      handle: "filesystem"
    },
    {
      src: "(.*)",
      dest: "/.vercel/functions/server/index"
    }
  ];
  await writeFile(resolve(nitro.options.output.dir, "config/routes.json"), JSON.stringify(routes, null, 2));
}

const worker = defineNitroPreset({
  entry: null,
  node: false,
  minify: true,
  externals: false,
  inlineDynamicImports: true
});

const PRESETS = {
  __proto__: null,
  azure_functions: azure_functions,
  azure: azure,
  browser: browser,
  cloudflare: cloudflare,
  firebase: firebase,
  lambda: lambda,
  netlify: netlify,
  netlify_builder: netlify_builder,
  node: node,
  dev: dev,
  prerender: prerender$1,
  server: server,
  cli: cli,
  vercel: vercel,
  worker: worker
};

const NitroDefaults = {
  dev: false,
  preset: void 0,
  logLevel: 3,
  runtimeConfig: {
    public: {},
    private: {}
  },
  app: {
    baseURL: "/",
    cdnURL: void 0,
    buildAssetsDir: "dist"
  },
  scanDirs: [],
  buildDir: ".nitro",
  output: {
    dir: "{{ rootDir }}/.output",
    serverDir: "{{ output.dir }}/server",
    publicDir: "{{ output.dir }}/public"
  },
  experimental: {},
  storage: { mounts: {} },
  publicAssets: [],
  serverAssets: [],
  handlers: [],
  routes: {},
  prerender: {
    crawlLinks: false,
    routes: []
  },
  alias: {
    "#nitro": runtimeDir
  },
  unenv: {},
  analyze: false,
  moduleSideEffects: ["unenv/runtime/polyfill/"],
  replace: {},
  nodeModulesDirs: [],
  hooks: {},
  commands: {}
};
async function loadOptions(userConfig = {}) {
  userConfig = klona(userConfig);
  const { config } = await loadConfig({
    name: "nitro",
    defaults: NitroDefaults,
    cwd: userConfig.rootDir,
    resolve(id) {
      if (PRESETS[id]) {
        return {
          config: PRESETS[id]
        };
      }
      return null;
    },
    overrides: {
      ...userConfig,
      extends: [
        userConfig.preset || process.env.NITRO_PRESET || detectTarget() || "server"
      ]
    }
  });
  const options = klona(config);
  options._config = userConfig;
  options.rootDir = resolve(options.rootDir || ".");
  options.srcDir = resolve(options.srcDir || options.rootDir);
  for (const key of ["srcDir", "publicDir", "buildDir"]) {
    options[key] = resolve(options.rootDir, options[key]);
  }
  options.entry = resolvePath(options.entry, options);
  options.output.dir = resolvePath(options.output.dir, options);
  options.output.publicDir = resolvePath(options.output.publicDir, options);
  options.output.serverDir = resolvePath(options.output.serverDir, options);
  options.nodeModulesDirs.push(resolve(options.rootDir, "node_modules"));
  options.nodeModulesDirs.push(resolve(pkgDir, "node_modules"));
  options.nodeModulesDirs = Array.from(new Set(options.nodeModulesDirs));
  if (!options.scanDirs.length) {
    options.scanDirs = [options.srcDir];
  }
  options.runtimeConfig = defu(options.runtimeConfig, {
    public: {
      app: options.app
    }
  });
  for (const asset of options.publicAssets) {
    asset.dir = resolve(options.srcDir, asset.dir);
    asset.baseURL = withLeadingSlash(withoutTrailingSlash(asset.baseURL || "/"));
  }
  return options;
}
function defineNitroConfig(config) {
  return config;
}

async function createNitro(config = {}) {
  const options = await loadOptions(config);
  const nitro = {
    options,
    hooks: createHooks(),
    vfs: {},
    logger: consola.withTag("nitro"),
    scannedHandlers: []
  };
  if (nitro.options.logLevel !== void 0) {
    nitro.logger.level = nitro.options.logLevel;
  }
  nitro.hooks.addHooks(nitro.options.hooks);
  for (const dir of options.scanDirs) {
    const publicDir = resolve(dir, "public");
    if (!existsSync(publicDir)) {
      continue;
    }
    if (options.publicAssets.find((asset) => asset.dir === publicDir)) {
      continue;
    }
    options.publicAssets.push({ dir: publicDir });
  }
  for (const asset of options.publicAssets) {
    asset.baseURL = asset.baseURL || "/";
    const isTopLevel = asset.baseURL === "/";
    asset.fallthrough = asset.fallthrough ?? isTopLevel;
    asset.maxAge = asset.maxAge ?? (isTopLevel ? 0 : 60);
  }
  nitro.options.serverAssets.push({
    baseName: "server",
    dir: resolve(nitro.options.srcDir, "assets")
  });
  if (nitro.options.autoImport) {
    nitro.unimport = createUnimport(nitro.options.autoImport);
  }
  if (options.dev) {
    const fsMounts = {
      root: resolve(options.rootDir),
      src: resolve(options.srcDir),
      build: resolve(options.buildDir),
      cache: resolve(options.buildDir, "cache")
    };
    for (const p in fsMounts) {
      options.storage.mounts[p] = options.storage.mounts[p] || {
        driver: "fs",
        driverOptions: { base: fsMounts[p] }
      };
    }
  }
  return nitro;
}

function createVFSHandler(nitro) {
  return defineEventHandler((event) => {
    if (event.req.url === "/") {
      const items = Object.keys(nitro.vfs).filter((i) => !i.startsWith("#")).map((key) => `<li><a href="/_vfs/${encodeURIComponent(key)}">${key.replace(nitro.options.rootDir, "")}</a></li>`).join("\n");
      return `<!doctype html><html><body><ul>${items}</ul></body></html>`;
    }
    const param = decodeURIComponent(event.req.url.slice(1));
    if (param in nitro.vfs) {
      return editorTemplate({
        readOnly: true,
        language: param.endsWith("html") ? "html" : "javascript",
        theme: "vs-dark",
        value: nitro.vfs[param]
      });
    }
    throw createError({ message: "File not found", statusCode: 404 });
  });
}
const monacoVersion = "0.30.0";
const monacoUrl = `https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/${monacoVersion}/min`;
const vsUrl = `${monacoUrl}/vs`;
const editorTemplate = (options) => `
<!doctype html>
<html>
<head>
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="${vsUrl}/editor/editor.main.min.css">
</head>
<body style="margin: 0">
<div id="editor" style="height:100vh"></div>
<script src="${vsUrl}/loader.min.js"><\/script>
<script>
  require.config({ paths: { vs: '${vsUrl}' } })

  const proxy = URL.createObjectURL(new Blob([\`
    self.MonacoEnvironment = { baseUrl: '${monacoUrl}' }
    importScripts('${vsUrl}/base/worker/workerMain.min.js')
  \`], { type: 'text/javascript' }))
  window.MonacoEnvironment = { getWorkerUrl: () => proxy }

  require(['vs/editor/editor.main'], function () {
    monaco.editor.create(document.getElementById('editor'), ${JSON.stringify(options)})
  })
<\/script>
</body>
</html>
`;

function initWorker(filename) {
  if (!existsSync(filename)) {
    return null;
  }
  return new Promise((resolve2, reject) => {
    const worker = new Worker(filename);
    worker.once("exit", (code) => {
      reject(new Error(code ? "[worker] exited with code: " + code : "[worker] exited"));
    });
    worker.once("error", (err) => {
      err.message = "[worker init]" + err.message;
      reject(err);
    });
    const addressLitener = (event) => {
      if (!event || !event.address) {
        return;
      }
      worker.off("message", addressLitener);
      resolve2({
        worker,
        address: event.address
      });
    };
    worker.on("message", addressLitener);
  });
}
async function killWorker(worker) {
  if (!worker) {
    return;
  }
  worker.worker.removeAllListeners();
  await worker.worker?.terminate();
  worker.worker = null;
  if (worker.address.socketPath && existsSync(worker.address.socketPath)) {
    await promises.rm(worker.address.socketPath);
  }
}
function createDevServer(nitro) {
  const workerEntry = resolve(nitro.options.output.dir, nitro.options.output.serverDir, "index.mjs");
  let lastError = null;
  let reloadPromise = null;
  let currentWorker = null;
  async function _reload() {
    const oldWorker = currentWorker;
    currentWorker = null;
    await killWorker(oldWorker);
    currentWorker = await initWorker(workerEntry);
  }
  const reload = debounce(() => {
    reloadPromise = _reload().then(() => {
      lastError = null;
    }).catch((error) => {
      console.error("[worker reload]", error);
      lastError = error;
    }).finally(() => {
      reloadPromise = null;
    });
    return reloadPromise;
  });
  nitro.hooks.hook("nitro:dev:reload", reload);
  const app = createApp();
  for (const asset of nitro.options.publicAssets) {
    app.use(joinURL(nitro.options.app.baseURL, asset.baseURL), serveStatic(asset.dir, {
      fallthrough: asset.fallthrough
    }));
  }
  app.use("/_vfs", createVFSHandler(nitro));
  const legacyMiddleware = createDynamicMiddleware();
  const devMiddleware = createDynamicMiddleware();
  app.use(legacyMiddleware.middleware);
  app.use(devMiddleware.middleware);
  const proxy = httpProxy.createProxy();
  app.use(defineEventHandler(async (event) => {
    await reloadPromise;
    const address = currentWorker?.address;
    if (!address || address.socketPath && !existsSync(address.socketPath)) {
      return sendUnavailable(event, lastError);
    }
    if (event.req.spa) {
      event.req.headers["x-nuxt-no-ssr"] = "true";
    }
    return new Promise((resolve2, reject) => {
      proxy.web(event.req, event.res, { target: address }, (error) => {
        lastError = error;
        if (error.code !== "ECONNRESET") {
          reject(error);
        }
        resolve2();
      });
    });
  }));
  let listeners = [];
  const _listen = async (port, opts) => {
    const listener = await listen(app, { port, ...opts });
    listeners.push(listener);
    return listener;
  };
  const pattern = "**/*.{js,json,cjs,mjs}";
  const events = ["add", "change"];
  let watcher;
  function watch() {
    if (watcher) {
      return;
    }
    watcher = chokidar.watch([
      resolve(nitro.options.output.serverDir, pattern),
      resolve(nitro.options.buildDir, "dist/server", pattern)
    ]).on("all", (event) => events.includes(event) && reload());
  }
  async function close() {
    if (watcher) {
      await watcher.close();
    }
    await killWorker(currentWorker);
    await Promise.all(listeners.map((l) => l.close()));
    listeners = [];
  }
  nitro.hooks.hook("close", close);
  return {
    reload,
    listen: _listen,
    app,
    close,
    watch,
    setLegacyMiddleware: legacyMiddleware.set,
    setDevMiddleware: devMiddleware.set
  };
}
function sendUnavailable(event, error) {
  event.res.setHeader("Content-Type", "text/html; charset=UTF-8");
  event.res.statusCode = 503;
  event.res.statusMessage = "Service Unavailable";
  event.res.end(`<!DOCTYPE html>
  <html lang="en">
  <head>
    <title>Nitro dev server</title>
    <style> body { margin: 2em; } </style>
  </head>
  </head>
  <body>
    <h1>Nitro worker is unavailable.</h1>
    ${error ? `<pre>${error.stack}</pre>` : "Please try again in a few seconds..."}
  </body>
</html>
`);
}
function createDynamicMiddleware() {
  let middleware;
  return {
    set: (input) => {
      if (!Array.isArray(input)) {
        middleware = input;
        return;
      }
      const app = connect();
      for (const m of input) {
        app.use(m.path || m.route || "/", m.handler || m.handle);
      }
      middleware = app;
    },
    middleware: (req, res, next) => middleware ? middleware(req, res, next) : next()
  };
}

const CRAWL_EXTENSIONS = /* @__PURE__ */ new Set(["", ".html", ".json"]);
async function prerender(nitro) {
  const routes = new Set(nitro.options.prerender.routes);
  if (nitro.options.prerender.crawlLinks && !routes.size) {
    routes.add("/");
  }
  if (!routes.size) {
    return;
  }
  nitro.logger.start("Preparing prerenderer...");
  const nitroRenderer = await createNitro({
    ...nitro.options._config,
    rootDir: nitro.options.rootDir,
    logLevel: 0,
    preset: "prerender"
  });
  await build(nitroRenderer);
  const app = await import(resolve(nitroRenderer.options.output.serverDir, "index.mjs"));
  const generatedRoutes = /* @__PURE__ */ new Set();
  const generateRoute = async (route) => {
    const res = await app.localFetch(route);
    const contents = await res.text();
    const additionalExtension = getExtension(route) ? "" : guessExt(res.headers.get("content-type"));
    const routeWithIndex = route.endsWith("/") ? route + "index" : route;
    const fileName = routeWithIndex + additionalExtension;
    const filePath = join(nitro.options.output.publicDir, fileName);
    await writeFile(filePath, contents);
    const rPath = relative(process.cwd(), filePath);
    nitro.logger.log(` - [${res.status}] Prerendered \`${route}\` to \`${rPath}\``);
    if (nitro.options.prerender.crawlLinks && fileName.endsWith(".html")) {
      const extractedLinks = extractLinks(contents).filter((link) => !generatedRoutes.has(link) && link.match(/^\//g) && CRAWL_EXTENSIONS.has(getExtension(link)));
      for (const route2 of extractedLinks) {
        routes.add(route2);
      }
    }
  };
  const generateAll = async () => {
    const results = await Promise.all(Array.from(routes).map(async (route) => {
      if (generatedRoutes.has(route)) {
        return false;
      }
      generatedRoutes.add(route);
      await generateRoute(route).catch((error) => {
        nitro.logger.error(`Error while generating route ${route}`, error);
      });
      return true;
    }));
    return results.filter(Boolean).length;
  };
  for (let i = 0; i < 100; i++) {
    const routesGenerated = await generateAll();
    if (!routesGenerated) {
      break;
    }
  }
}
const LINK_REGEX = /href=['"]?([^'" >]+)/g;
function extractLinks(html, _url) {
  const links = [];
  for (const match of html.matchAll(LINK_REGEX)) {
    links.push(match[1]);
  }
  return links;
}
const EXT_REGEX = /\.[a-z0-9]+$/;
function getExtension(path) {
  return (path.match(EXT_REGEX) || [])[0] || "";
}
const ContentTypeToExt = {
  json: ".json",
  html: ".html"
};
function guessExt(contentType = "") {
  for (const pattern in ContentTypeToExt) {
    if (contentType.includes(pattern)) {
      return ContentTypeToExt[pattern];
    }
  }
  return "";
}

export { GLOB_SCAN_PATTERN as G, createNitro as a, build as b, copyPublicAssets as c, scanMiddleware as d, scanAPI as e, createDevServer as f, defineNitroConfig as g, prerender as h, loadOptions as l, prepare as p, scanHandlers as s, writeTypes as w };
