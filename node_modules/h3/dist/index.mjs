import { withoutTrailingSlash, withoutBase, getQuery } from 'ufo';
import { createRouter as createRouter$1 } from 'radix3';
import destr from 'destr';
import { parse, serialize } from 'cookie-es';

const defineHandle = (handler) => handler;
const defineMiddleware = (middleware) => middleware;
function promisifyHandle(handle) {
  return function(req, res) {
    return callHandle(handle, req, res);
  };
}
function callHandle(handle, req, res) {
  return new Promise((resolve, reject) => {
    const next = (err) => err ? reject(err) : resolve(void 0);
    try {
      const returned = handle(req, res, next);
      if (returned !== void 0) {
        resolve(returned);
      } else {
        res.once("close", next);
        res.once("error", next);
      }
    } catch (err) {
      next(err);
    }
  });
}
function lazyHandle(handle, promisify) {
  let _promise;
  const resolve = () => {
    if (!_promise) {
      _promise = Promise.resolve(handle()).then((r) => promisify ? promisifyHandle(r.default || r) : r.default || r);
    }
    return _promise;
  };
  return function(req, res) {
    return resolve().then((h) => h(req, res));
  };
}
function useBase(base, handle) {
  base = withoutTrailingSlash(base);
  if (!base) {
    return handle;
  }
  return function(req, res) {
    req.originalUrl = req.originalUrl || req.url || "/";
    req.url = withoutBase(req.url || "/", base);
    return handle(req, res);
  };
}

function useQuery(req) {
  return getQuery(req.url || "");
}
function useMethod(req, defaultMethod = "GET") {
  return (req.method || defaultMethod).toUpperCase();
}
function isMethod(req, expected, allowHead) {
  const method = useMethod(req);
  if (allowHead && method === "HEAD") {
    return true;
  }
  if (typeof expected === "string") {
    if (method === expected) {
      return true;
    }
  } else if (expected.includes(method)) {
    return true;
  }
  return false;
}
function assertMethod(req, expected, allowHead) {
  if (!isMethod(req, expected, allowHead)) {
    throw createError({
      statusCode: 405,
      statusMessage: "HTTP method is not allowed."
    });
  }
}

const RawBodySymbol = Symbol("h3RawBody");
const ParsedBodySymbol = Symbol("h3RawBody");
const PayloadMethods = ["PATCH", "POST", "PUT", "DELETE"];
function useRawBody(req, encoding = "utf-8") {
  assertMethod(req, PayloadMethods);
  if (RawBodySymbol in req) {
    const promise2 = Promise.resolve(req[RawBodySymbol]);
    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;
  }
  if ("body" in req) {
    return Promise.resolve(req.body);
  }
  const promise = req[RawBodySymbol] = new Promise((resolve, reject) => {
    const bodyData = [];
    req.on("error", (err) => {
      reject(err);
    }).on("data", (chunk) => {
      bodyData.push(chunk);
    }).on("end", () => {
      resolve(Buffer.concat(bodyData));
    });
  });
  return encoding ? promise.then((buff) => buff.toString(encoding)) : promise;
}
async function useBody(req) {
  if (ParsedBodySymbol in req) {
    return req[ParsedBodySymbol];
  }
  const body = await useRawBody(req);
  const json = destr(body);
  req[ParsedBodySymbol] = json;
  return json;
}

const MIMES = {
  html: "text/html",
  json: "application/json"
};

const defer = typeof setImmediate !== "undefined" ? setImmediate : (fn) => fn();
function send(res, data, type) {
  if (type) {
    defaultContentType(res, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      res.end(data);
      resolve(void 0);
    });
  });
}
function defaultContentType(res, type) {
  if (type && !res.getHeader("Content-Type")) {
    res.setHeader("Content-Type", type);
  }
}
function sendRedirect(res, location, code = 302) {
  res.statusCode = code;
  res.setHeader("Location", location);
  return send(res, "Redirecting to " + location, MIMES.html);
}
function appendHeader(res, name, value) {
  let current = res.getHeader(name);
  if (!current) {
    res.setHeader(name, value);
    return;
  }
  if (!Array.isArray(current)) {
    current = [current.toString()];
  }
  res.setHeader(name, current.concat(value));
}
function isStream(data) {
  return typeof data === "object" && typeof data.pipe === "function" && typeof data.on === "function";
}
function sendStream(res, data) {
  return new Promise((resolve, reject) => {
    data.pipe(res);
    data.on("end", () => resolve(void 0));
    data.on("error", (error) => reject(createError(error)));
  });
}

function useCookies(req) {
  return parse(req.headers.cookie || "");
}
function useCookie(req, name) {
  return useCookies(req)[name];
}
function setCookie(res, name, value, serializeOptions) {
  const cookieStr = serialize(name, value, serializeOptions);
  appendHeader(res, "Set-Cookie", cookieStr);
}
function deleteCookie(res, name, serializeOptions) {
  setCookie(res, name, "", {
    ...serializeOptions,
    maxAge: 0
  });
}

class H3Error extends Error {
  constructor() {
    super(...arguments);
    this.statusCode = 500;
    this.statusMessage = "H3Error";
  }
}
function createError(input) {
  if (input instanceof H3Error) {
    return input;
  }
  const err = new H3Error(input.message ?? input.statusMessage);
  if (input.statusCode) {
    err.statusCode = input.statusCode;
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  }
  if (input.data) {
    err.data = input.data;
  }
  return err;
}
function sendError(res, error, debug) {
  let h3Error;
  if (error instanceof H3Error) {
    h3Error = error;
  } else {
    console.error(error);
    h3Error = createError(error);
  }
  if (res.writableEnded) {
    return;
  }
  res.statusCode = h3Error.statusCode;
  res.statusMessage = h3Error.statusMessage;
  const responseBody = {
    statusCode: res.statusCode,
    statusMessage: res.statusMessage,
    stack: [],
    data: h3Error.data
  };
  if (debug) {
    responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
  }
  res.setHeader("Content-Type", MIMES.json);
  res.end(JSON.stringify(responseBody, null, 2));
}

function createApp(options = {}) {
  const stack = [];
  const _handle = createHandle(stack, options);
  const app = function(req, res) {
    return _handle(req, res).catch((error) => {
      if (options.onError) {
        return options.onError(error, req, res);
      }
      return sendError(res, error, !!options.debug);
    });
  };
  app.stack = stack;
  app._handle = _handle;
  app.use = (arg1, arg2, arg3) => use(app, arg1, arg2, arg3);
  return app;
}
function use(app, arg1, arg2, arg3) {
  if (Array.isArray(arg1)) {
    arg1.forEach((i) => use(app, i, arg2, arg3));
  } else if (Array.isArray(arg2)) {
    arg2.forEach((i) => use(app, arg1, i, arg3));
  } else if (typeof arg1 === "string") {
    app.stack.push(normalizeLayer({ ...arg3, route: arg1, handle: arg2 }));
  } else if (typeof arg1 === "function") {
    app.stack.push(normalizeLayer({ ...arg2, route: "/", handle: arg1 }));
  } else {
    app.stack.push(normalizeLayer({ ...arg1 }));
  }
  return app;
}
function createHandle(stack, options) {
  const spacing = options.debug ? 2 : void 0;
  return async function handle(req, res) {
    req.originalUrl = req.originalUrl || req.url || "/";
    const reqUrl = req.url || "/";
    for (const layer of stack) {
      if (layer.route.length > 1) {
        if (!reqUrl.startsWith(layer.route)) {
          continue;
        }
        req.url = reqUrl.slice(layer.route.length) || "/";
      } else {
        req.url = reqUrl;
      }
      if (layer.match && !layer.match(req.url, req)) {
        continue;
      }
      const val = await layer.handle(req, res);
      if (res.writableEnded) {
        return;
      }
      const type = typeof val;
      if (type === "string") {
        return send(res, val, MIMES.html);
      } else if (isStream(val)) {
        return sendStream(res, val);
      } else if (type === "object" || type === "boolean" || type === "number") {
        if (val && val.buffer) {
          return send(res, val);
        } else if (val instanceof Error) {
          throw createError(val);
        } else {
          return send(res, JSON.stringify(val, null, spacing), MIMES.json);
        }
      }
    }
    if (!res.writableEnded) {
      throw createError({ statusCode: 404, statusMessage: "Not Found" });
    }
  };
}
function normalizeLayer(layer) {
  if (layer.promisify === void 0) {
    layer.promisify = layer.handle.length > 2;
  }
  return {
    route: withoutTrailingSlash(layer.route),
    match: layer.match,
    handle: layer.lazy ? lazyHandle(layer.handle, layer.promisify) : layer.promisify ? promisifyHandle(layer.handle) : layer.handle
  };
}

const RouterMethods = ["connect", "delete", "get", "head", "options", "post", "put", "trace"];
function createRouter() {
  const _router = createRouter$1({});
  const routes = {};
  const router = {};
  router.add = (path, handle, method = "all") => {
    let route = routes[path];
    if (!route) {
      routes[path] = route = { handlers: {} };
      _router.insert(path, route);
    }
    route.handlers[method] = handle;
    return router;
  };
  for (const method of RouterMethods) {
    router[method] = (path, handle) => router.add(path, handle, method);
  }
  router.handle = (req, res) => {
    const matched = _router.lookup(req.url || "/");
    if (!matched) {
      throw createError({
        statusCode: 404,
        name: "Not Found",
        statusMessage: `Cannot find any route matching ${req.url || "/"}.`
      });
    }
    const method = (req.method || "get").toLowerCase();
    const handler = matched.handlers[method] || matched.handlers.all;
    if (!handler) {
      throw createError({
        statusCode: 405,
        name: "Method Not Allowed",
        statusMessage: `Method ${method} is not allowed on this route.`
      });
    }
    req.params = matched.params || {};
    return handler(req, res);
  };
  return router;
}

export { H3Error, MIMES, appendHeader, assertMethod, callHandle, createApp, createError, createHandle, createRouter, defaultContentType, defineHandle, defineMiddleware, deleteCookie, isMethod, isStream, lazyHandle, promisifyHandle, send, sendError, sendRedirect, sendStream, setCookie, use, useBase, useBody, useCookie, useCookies, useMethod, useQuery, useRawBody };
